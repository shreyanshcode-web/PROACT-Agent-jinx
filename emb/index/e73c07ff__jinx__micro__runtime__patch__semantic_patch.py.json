{"file_rel": "jinx\\micro\\runtime\\patch\\semantic_patch.py", "file_sha256": "9f7c29d22941b8a20c0045d10e31443e1561d311ad43e375919e452a331dd8e4", "updated_ts": 1760763313.3496187, "total_chunks": 5, "chunks": [{"sha": "25b21431390f90ef2546f6fae84d1519b333855f8ae7a101e27c2fb2d6c33fa1", "index": 0, "path": "e73c07ff__jinx__micro__runtime__patch__semantic_patch.py\\25b21431390f90ef2546f6fae84d1519b333855f8ae7a101e27c2fb2d6c33fa1.json", "terms": ["str", "import", "path", "int", "from", "def", "return", "getenv", "_get_root", "_rel_to_root", "search_project_cached", "default", "except", "exception", "jinx", "list", "name", "query", "root", "topk", "try", "tuple", "__future__", "_best_hit_in_file", "_truthy"], "text_preview": "from __future__ import annotations\n\nimport os\nimport difflib\nfrom typing import Optional, Tuple, List\n\nfrom jinx.async_utils.fs import read_text_raw, write_text\nfrom jinx.micro.embeddings.search_cache import search_project_cached\nfrom .utils import (\n    u", "line_start": 1, "line_end": 44}, {"sha": "a08e06cdf07ff9dae7998803bd5ad94fe95e3b558b686349a0e4aedba69d5d40", "index": 1, "path": "e73c07ff__jinx__micro__runtime__patch__semantic_patch.py\\a08e06cdf07ff9dae7998803bd5ad94fe95e3b558b686349a0e4aedba69d5d40.json", "terms": ["none", "return", "best_score_local", "int", "score", "best_local", "le0", "ls0", "best", "candidates", "get", "lines", "_score_candidates", "best_score", "rep_lines", "join", "tuple", "and", "await", "cur", "file", "for", "hits", "margin", "the"], "text_preview": "# Prefer hits that are in the same file\n    candidates = [h for h in (hits or []) if str(h.get(\"file\") or \"\").replace(\"\\\\\", \"/\") == rel]\n    if not candidates:\n        return None\n    # Score by fuzzy similarity between rep_lines and the window (offloaded)", "line_start": 45, "line_end": 73}, {"sha": "26a83293901ac7fe0bac7d55ddf52811f2cb147835721222853ecea0e8348ebf", "index": 2, "path": "e73c07ff__jinx__micro__runtime__patch__semantic_patch.py\\26a83293901ac7fe0bac7d55ddf52811f2cb147835721222853ecea0e8348ebf.json", "terms": ["int", "none", "cur", "str", "not", "optional", "file", "float", "margin", "tol", "topk", "else", "except", "exception", "getenv", "try", "window", "bool", "embeddings", "eol", "false", "path", "replacement", "splitlines", "the"], "text_preview": "async def patch_semantic_in_file(path: str, query: str, replacement: str, *, preview: bool = False, topk: Optional[int] = None, margin: Optional[int] = None, tol: Optional[float] = None) -> Tuple[bool, str]:\n    \"\"\"Patch a large file by locating the best i", "line_start": 74, "line_end": 100}, {"sha": "62a4d705fc12e5d760422f4d28dea7a59f5eb32176818eb316f41191851484b0", "index": 3, "path": "e73c07ff__jinx__micro__runtime__patch__semantic_patch.py\\62a4d705fc12e5d760422f4d28dea7a59f5eb32176818eb316f41191851484b0.json", "terms": ["loc", "best_i", "best_r_local", "rep_lines", "none", "window", "best_i_local", "lines", "_best_window", "ls0", "join", "await", "len", "query", "return", "the", "try", "win", "_best_hit_in_file", "_truthy", "base_indent", "best_r", "jinx_semantic_patch_enable", "le0", "leading_ws"], "text_preview": "# Try embedding-guided window\n    loc = None\n    try:\n        if _truthy(\"JINX_SEMANTIC_PATCH_ENABLE\", \"1\") and query:\n            loc = await _best_hit_in_file(path, query, rep_lines, topk=k, margin=mg, tol=tl)\n    except Exception:\n        loc = None\n\n  ", "line_start": 101, "line_end": 130}, {"sha": "10aa6da00afc221fc20ef6c7c4eb4dcabc33915837a9ba4c7117c1f97e53f954", "index": 4, "path": "e73c07ff__jinx__micro__runtime__patch__semantic_patch.py\\10aa6da00afc221fc20ef6c7c4eb4dcabc33915837a9ba4c7117c1f97e53f954.json", "terms": ["path", "out", "return", "out_lines", "rep_aligned", "rep_norm", "unified_diff", "lines", "await", "cur", "true", "base_indent", "join_lines", "le0", "ls0", "normalize_indentation", "rep_lines", "syntax_check_enabled", "to_thread", "trailing_nl", "write_text", "and", "ast", "asyncio", "else"], "text_preview": "rep_norm = normalize_indentation(rep_lines)\n    rep_aligned = [(base_indent + ln) if ln.strip() else ln for ln in rep_norm]\n\n    out_lines = lines[: ls0 - 1] + rep_aligned + lines[le0 :]\n    out = join_lines(out_lines, eol, trailing_nl)\n    if preview:\n   ", "line_start": 131, "line_end": 144}], "file_terms": ["none", "int", "path", "str", "return", "rep_lines", "lines", "cur", "import", "await", "try", "window", "margin", "def", "except", "exception", "ls0", "float", "tol", "topk", "tuple", "getenv", "loc", "not", "the"]}