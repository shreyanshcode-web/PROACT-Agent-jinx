{"file_rel": "jinx\\micro\\conversation\\formatting.py", "file_sha256": "550499f74c1abf60b0f4aeab9e4e1595c2c054b33a846f45d6d769811670a26b", "updated_ts": 1760763310.3586066, "total_chunks": 6, "chunks": [{"sha": "1d2968752950917d6aeba5c2bc6c259e3b0029398e26bca591a33d08d63ecc44", "index": 0, "path": "308b09fe__jinx__micro__conversation__formatting.py\\1d2968752950917d6aeba5c2bc6c259e3b0029398e26bca591a33d08d63ecc44.json", "terms": ["line", "blank", "embeddings_refs", "evergreen", "from", "import", "memory", "task", "embeddings_code", "embeddings_context", "header", "str", "between", "blocks", "error", "optional", "text", "__future__", "ensure_header_block_separation", "format_normalization", "normalize_unicode_spaces", "and", "annotations", "assembling", "build"], "text_preview": "from __future__ import annotations\n\n\"\"\"Utilities for assembling and normalizing conversation headers.\n\nProvides helpers to:\n- normalize unicode/nbspace characters\n- enforce blank-line separation between known header blocks\n- build the standardized header t", "line_start": 1, "line_end": 33}, {"sha": "7961eeb9f2f619bc4108a8c7a662b8cd9bcffea72cc092006c072528cbca72ba", "index": 1, "path": "308b09fe__jinx__micro__conversation__formatting.py\\7961eeb9f2f619bc4108a8c7a662b8cd9bcffea72cc092006c072528cbca72ba.json", "terms": ["embeddings_code", "embeddings_context", "embeddings_refs", "evergreen", "embeddings_memory", "plan_kernels", "u00a0", "u2007", "u202f", "sub", "normalize_unicode_spaces", "any", "between", "blank", "blocks", "exactly", "existing", "including", "line", "newlines", "normalize", "one", "text", "whitespace"], "text_preview": "t = normalize_unicode_spaces(text)\n    # Normalize any whitespace (including existing newlines) between blocks to exactly one blank line\n    t = re.sub(r\"(</embeddings_context>)[\\s\\u00A0\\u2007\\u202F]*(<evergreen>)\", r\"\\1\\n\\n\\2\", t)\n    t = re.sub(r\"(</embe", "line_start": 34, "line_end": 45}, {"sha": "69d99d4b1f0b4234e7b9d7f5a928becba6dc140cc494bb24051c05774a74f133", "index": 2, "path": "308b09fe__jinx__micro__conversation__formatting.py\\69d99d4b1f0b4234e7b9d7f5a928becba6dc140cc494bb24051c05774a74f133.json", "terms": ["embeddings_memory", "embeddings_code", "embeddings_refs", "evergreen", "memory", "plan_kernels", "error", "task"], "text_preview": "t = re.sub(r\"(</embeddings_refs>)[\\s\\u00A0\\u2007\\u202F]*(<plan_kernels>)\", r\"\\1\\n\\n\\2\", t)\n    t = re.sub(r\"(</embeddings_refs>)[\\s\\u00A0\\u2007\\u202F]*(<embeddings_memory>)\", r\"\\1\\n\\n\\2\", t)\n    t = re.sub(r\"(</embeddings_code>)[\\s\\u00A0\\u2007\\u202F]*(<mem", "line_start": 46, "line_end": 58}, {"sha": "21dad55f8c8c433d80741cb0a62c33b6b9d0173950ceea52ee5fb3d70c22c3e2", "index": 3, "path": "308b09fe__jinx__micro__conversation__formatting.py\\21dad55f8c8c433d80741cb0a62c33b6b9d0173950ceea52ee5fb3d70c22c3e2.json", "terms": ["none", "str", "u00a0", "u2007", "u202f", "sub", "task", "embeddings_refs", "plan_kernels", "wrapped", "error", "memory", "and", "blocks", "ctx", "parts", "build_header", "embeddings_code", "embeddings_context", "error_text", "evergreen_text", "mem_text", "task_text", "already", "assumed"], "text_preview": "t = re.sub(r\"(</plan_kernels>)[\\s\\u00A0\\u2007\\u202F]*(<memory>)\", r\"\\1\\n\\n\\2\", t)\n    t = re.sub(r\"(</plan_kernels>)[\\s\\u00A0\\u2007\\u202F]*(<task>)\", r\"\\1\\n\\n\\2\", t)\n    t = re.sub(r\"(</plan_kernels>)[\\s\\u00A0\\u2007\\u202F]*(<error>)\", r\"\\1\\n\\n\\2\", t)\n    t", "line_start": 59, "line_end": 78}, {"sha": "a9a371f500b692bddb93a1fc484799328bc76e48d589a13a3d89bc64537d9404", "index": 4, "path": "308b09fe__jinx__micro__conversation__formatting.py\\a9a371f500b692bddb93a1fc484799328bc76e48d589a13a3d89bc64537d9404.json", "terms": ["strip", "tag", "str", "parts", "core", "and", "append", "return", "_is_wrapped", "error_text", "evergreen_text", "mem_text", "task_text", "evergreen", "memory", "ctx", "else", "not", "embeddings_context", "ev_block", "mem_block", "error", "task", "def", "_wrap_if_needed"], "text_preview": "def _is_wrapped(s: str, tag: str) -> bool:\n        if not s:\n            return False\n        ss = s.strip()\n        return ss.startswith(f\"<{tag}\") and ss.endswith(f\"</{tag}>\")\n\n    def _wrap_if_needed(s: str, tag: str) -> str:\n        core = (s or \"\").st", "line_start": 79, "line_end": 107}, {"sha": "fff829709dadbbe0c4df72c198f5dc8e4b267cb71979f76550e4f229b4741833", "index": 5, "path": "308b09fe__jinx__micro__conversation__formatting.py\\fff829709dadbbe0c4df72c198f5dc8e4b267cb71979f76550e4f229b4741833.json", "terms": ["header_text", "tag", "memory", "cur", "str", "_collapse_nested", "prev", "nested", "pat", "return", "text", "ensure_header_block_separation", "accidental", "are", "blocks", "collapse", "compile", "def", "evergreen", "found", "identical", "ignorecase", "join", "like", "more"], "text_preview": "header_text = \"\\n\".join(parts)\n\n    # Collapse accidental nested identical blocks like <memory><memory>...</memory></memory>\n    def _collapse_nested(text: str, tag: str) -> str:\n        # Repeat until no more nested patterns are found\n        pat = re.com", "line_start": 108, "line_end": 125}], "file_terms": ["u00a0", "u2007", "u202f", "sub", "str", "memory", "embeddings_refs", "tag", "blank", "embeddings_code", "evergreen", "line", "embeddings_context", "task", "embeddings_memory", "strip", "header_text", "error", "parts", "none", "and", "return", "plan_kernels", "ctx", "cur"]}