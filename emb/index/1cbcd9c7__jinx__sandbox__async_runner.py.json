{"file_rel": "jinx\\sandbox\\async_runner.py", "file_sha256": "7b1878710283736bb27c6c858a9bdbedc333c18ebe22b5896421f8131616b912", "updated_ts": 1760763314.0968716, "total_chunks": 4, "chunks": [{"sha": "e684e81247a9e84889a2b2c2fc578949eced53e4a2f0ae9be1dd52ca0e1bf271", "index": 0, "path": "1cbcd9c7__jinx__sandbox__async_runner.py\\e684e81247a9e84889a2b2c2fc578949eced53e4a2f0ae9be1dd52ca0e1bf271.json", "terms": ["import", "from", "none", "jinx", "log_path", "code", "multiprocessing", "process", "run", "sandbox", "blast_zone", "make_run_log_path", "datetime", "str", "async", "awaitable", "callable", "def", "proc", "try", "__future__", "async_rename_run_log", "async_sandbox_task", "bomb_log", "clockwork_ghost"], "text_preview": "from __future__ import annotations\n\nimport asyncio\nimport multiprocessing\nimport os\nfrom datetime import datetime\nfrom typing import Awaitable, Callable\n\nfrom jinx.sandbox.executor import blast_zone\nfrom jinx.retry import detonate_payload\nfrom jinx.logging", "line_start": 1, "line_end": 33}, {"sha": "12b47124f8f37129e3707b7e30e115bf813a32896032987541ce2da7af0f693b", "index": 1, "path": "1cbcd9c7__jinx__sandbox__async_runner.py\\12b47124f8f37129e3707b7e30e115bf813a32896032987541ce2da7af0f693b.json", "terms": ["max_ms", "await", "exception", "proc", "get", "error", "except", "out", "log_path", "timeout_s", "to_thread", "asyncio", "avoid", "delay", "join", "output", "retries", "timeout", "try", "wait", "async_sandbox_task", "bomb_log", "clockwork_ghost", "detonate_payload", "is_alive"], "text_preview": "max_ms = int(os.getenv(\"JINX_SANDBOX_MAX_MS\", \"20000\"))\n                except Exception:\n                    max_ms = 20000\n                timeout_s = max(0.1, max_ms / 1000.0)\n                # Wait with timeout in a thread to avoid blocking the loop\n  ", "line_start": 34, "line_end": 58}, {"sha": "62750a67dc6b4822e2fcc552b48fbac1dc020e04708d51b68c5290296c0c86e9", "index": 2, "path": "1cbcd9c7__jinx__sandbox__async_runner.py\\62750a67dc6b4822e2fcc552b48fbac1dc020e04708d51b68c5290296c0c86e9.json", "terms": ["err", "log_path", "line", "error", "await", "out", "bomb_log", "except", "exception", "for", "log", "low", "not", "raw", "status", "the", "try", "async_rename_run_log", "jinx_error", "write_last_run", "and", "announcing", "based", "before", "best"], "text_preview": "# Sentinel-based error detection: if the code explicitly printed an ERROR line,\n            # surface it as an error to drive the recovery loop, even without exceptions.\n            if not err and out:\n                try:\n                    for raw in ou", "line_start": 59, "line_end": 82}, {"sha": "c2f0681365fb5ae43522d6cb06c95cc83c3cd7689549463392690c37323ec664", "index": 3, "path": "1cbcd9c7__jinx__sandbox__async_runner.py\\c2f0681365fb5ae43522d6cb06c95cc83c3cd7689549463392690c37323ec664.json", "terms": ["await", "error", "exception", "callback", "except", "pass", "async_rename_run_log", "bomb_log", "log_path", "best", "blocking", "bubbled", "effort", "ensure", "err", "even", "exile", "get", "index", "known", "log", "non", "path", "rename", "status"], "text_preview": "pass\n            if callback:\n                await callback(err)\n        except Exception as e:\n            await bomb_log(f\"System exile: {e}\")\n            # Best effort: index as error if log path is known\n            try:\n                lp = r.get(\"lo", "line_start": 83, "line_end": 95}], "file_terms": ["log_path", "import", "error", "await", "err", "exception", "from", "none", "except", "jinx", "try", "line", "out", "proc", "bomb_log", "sandbox", "max_ms", "get", "code", "for", "log", "pass", "process", "the", "async_rename_run_log"]}