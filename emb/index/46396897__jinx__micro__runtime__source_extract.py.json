{"file_rel": "jinx\\micro\\runtime\\source_extract.py", "file_sha256": "9a4f73a678b873ac3378e05256e68d1c4fe22954bcb9f3ada020653718d3b56b", "updated_ts": 1760763312.9180362, "total_chunks": 8, "chunks": [{"sha": "d4951c54f36fa50b120d8f5032751da242c01a0c3af7ed2c0634e708cadcf172", "index": 0, "path": "46396897__jinx__micro__runtime__source_extract.py\\d4951c54f36fa50b120d8f5032751da242c01a0c3af7ed2c0634e708cadcf172.json", "terms": ["ast", "int", "import", "node", "start", "getattr", "return", "lineno", "def", "from", "path", "str", "decos", "dmin", "end_lineno", "project_root", "and", "asyncio", "base", "end", "jinx", "min", "text", "tuple", "__future__"], "text_preview": "from __future__ import annotations\n\nimport os\nimport re\nimport asyncio\nimport ast\nfrom typing import Tuple, Dict, Any, Optional\n\nfrom jinx.async_utils.fs import read_text_raw\nfrom jinx.micro.embeddings.project_config import ROOT as PROJECT_ROOT\n\n\ndef _abs_", "line_start": 1, "line_end": 45}, {"sha": "634d950a858ca9dfe0ded8a8142fa39711a99717a4b2f184a1e9b1e6954308a2", "index": 1, "path": "46396897__jinx__micro__runtime__source_extract.py\\634d950a858ca9dfe0ded8a8142fa39711a99717a4b2f184a1e9b1e6954308a2.json", "terms": ["ast", "target", "str", "node", "bool", "getattr", "kind", "text", "include_decorators", "error", "int", "meta", "true", "apath", "await", "file", "name", "none", "path", "symbol", "tree", "try", "__class__", "__name__", "_abs_path"], "text_preview": "async def extract_symbol_source(path: str, symbol: str, *, include_decorators: bool = True, include_docstring: bool = True) -> Tuple[bool, str, Dict[str, Any]]:\n    \"\"\"Extract the exact source of a function/class by name from a file.\n\n    Returns: (ok, cod", "line_start": 46, "line_end": 69}, {"sha": "01363d13a340dea52cbcfd9b3ef6bd945e7db0fb79366e42ee6e32937d776172", "index": 2, "path": "46396897__jinx__micro__runtime__source_extract.py\\01363d13a340dea52cbcfd9b3ef6bd945e7db0fb79366e42ee6e32937d776172.json", "terms": ["first_stmt", "getattr", "value", "ast", "body", "isinstance", "none", "str", "doc_end", "is_doc", "docstring", "and", "lines", "e_eff", "end_lineno", "include_docstring", "constant", "else", "error", "except", "exception", "exclude", "expr", "false", "int"], "text_preview": "# If we intend to exclude docstring, shift start past docstring when present\n            if not include_docstring:\n                try:\n                    body = getattr(target, \"body\", None)\n                    if body:\n                        first_stmt", "line_start": 70, "line_end": 90}, {"sha": "4a9d454a24c86457baa9adda9559462d9299532cd7f728e4a676f7e3a5606f5a", "index": 3, "path": "46396897__jinx__micro__runtime__source_extract.py\\4a9d454a24c86457baa9adda9559462d9299532cd7f728e4a676f7e3a5606f5a.json", "terms": ["start_idx", "def", "kind", "lines", "text", "lstrip", "startswith", "class", "code", "fallback", "symbol", "e_eff", "header_re", "else", "async", "break", "end", "found", "not", "path", "prev", "return", "include_decorators", "apath", "ast"], "text_preview": "code = \"\\n\".join(lines[s - 1 : e_eff])\n            return True, code, {\"kind\": kind, \"start\": s, \"end\": e_eff, \"path\": apath}\n    except Exception:\n        # fall through to text fallback\n        pass\n\n    # Text-based fallback if AST path failed or symbol", "line_start": 91, "line_end": 120}, {"sha": "cf1c7aca8b0fe8ada343f4b702149327c02976404193a3c33061386fe0b5d460", "index": 4, "path": "46396897__jinx__micro__runtime__source_extract.py\\cf1c7aca8b0fe8ada343f4b702149327c02976404193a3c33061386fe0b5d460.json", "terms": ["end_idx", "first_nonempty", "lines", "start_idx", "len", "startswith", "lstrip", "not", "base_indent", "def", "and", "indent", "quote", "strip", "while", "include_docstring", "advance", "async", "best", "break", "class", "closed", "closing", "continue", "docstring"], "text_preview": "base_indent = len(lines[start_idx]) - len(lines[start_idx].lstrip())\n    end_idx = start_idx\n    for k in range(start_idx + 1, len(lines)):\n        l = lines[k]\n        if not l.strip():\n            end_idx = k\n            continue\n        indent = len(l) ", "line_start": 121, "line_end": 147}, {"sha": "abe6f04d6b723199038aada64b5a77cfd9dd6098d82bfcb2a45cdcad764c240e", "index": 5, "path": "46396897__jinx__micro__runtime__source_extract.py\\abe6f04d6b723199038aada64b5a77cfd9dd6098d82bfcb2a45cdcad764c240e.json", "terms": ["lines", "query", "text", "end_idx", "str", "error", "kind", "the", "apath", "path", "pos", "return", "first_nonempty", "include_docstring", "match_line", "start_idx", "data", "join", "quote", "closed", "code", "count", "else", "end", "false"], "text_preview": "if quote in lines[m] and (m != first_nonempty or lines[m].count(quote) >= 2):\n                            s = m + 1\n                            closed = True\n                            break\n                        m += 1\n                    if not closed", "line_start": 148, "line_end": 172}, {"sha": "7f68cc0db1ffde57193a1496723282459c5e97bc55b3d625565b96a9f4f75c70", "index": 6, "path": "46396897__jinx__micro__runtime__source_extract.py\\7f68cc0db1ffde57193a1496723282459c5e97bc55b3d625565b96a9f4f75c70.json", "terms": ["match_line", "node", "ast", "candidates", "def", "getattr", "int", "lines", "text", "class", "for", "span", "tree", "try", "__class__", "__name__", "_contains_lineno", "_node_range_with_decorators", "_parse_ast", "end_lineno", "header_re", "apath", "append", "async", "asyncfunctiondef"], "text_preview": "# Try AST-based first\n    try:\n        tree = await _parse_ast(text)\n        candidates: list[tuple[int, ast.AST]] = []\n        for node in ast.walk(tree):\n            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):\n            ", "line_start": 173, "line_end": 200}, {"sha": "b156c23afd0989cd4b9390b6916b98f2348bb83b3bc075098ed0c80b962739fb", "index": 7, "path": "46396897__jinx__micro__runtime__source_extract.py\\b156c23afd0989cd4b9390b6916b98f2348bb83b3bc075098ed0c80b962739fb.json", "terms": ["end_idx", "len", "match_line", "base_indent", "header_re", "end", "fallback", "indent", "lines", "lstrip", "match", "return", "sym", "symbol", "and", "apath", "break", "continue", "enclosing", "error", "extract", "false", "find", "for", "group"], "text_preview": "m = header_re.match(ln)\n        if m:\n            sym = m.group(1)\n            # find end similar to extract fallback\n            base_indent = len(ln) - len(ln.lstrip())\n            end_idx = i\n            for k in range(i + 1, len(lines)):\n              ", "line_start": 201, "line_end": 226}], "file_terms": ["ast", "node", "lines", "getattr", "text", "end_idx", "def", "return", "str", "int", "match_line", "start_idx", "start", "len", "kind", "path", "not", "end", "first_nonempty", "symbol", "first_stmt", "error", "and", "lstrip", "apath"]}