{"file_rel": "jinx\\micro\\conversation\\error_worker.py", "file_sha256": "af58751b5b736726789a4a868e874b71ca9abb7d3efc7ca1ac6305384d97208b", "updated_ts": 1760763310.3191137, "total_chunks": 3, "chunks": [{"sha": "9d1019d00cd2d229d967986deaeffa4fec2277ef7194d197c8592040a1cd4f42", "index": 0, "path": "824928ca__jinx__micro__conversation__error_worker.py\\9d1019d00cd2d229d967986deaeffa4fec2277ef7194d197c8592040a1cd4f42.json", "terms": ["none", "asyncio", "_err_queue", "_err_worker_task", "error", "import", "queue", "create_task", "shutdown_task", "done", "wait", "_error_retry_worker", "get_task", "jx_state", "shutdown_event", "the", "and", "def", "for", "from", "retries", "shutdown", "task", "worker", "__future__"], "text_preview": "from __future__ import annotations\n\n\"\"\"Error worker micro-module.\n\nProvides a dedicated background worker to serialize error-driven retries, decouple\nqueue lifecycle from the orchestrator, and support graceful shutdown via the\nshared shutdown_event.\n\"\"\"\n\ni", "line_start": 1, "line_end": 36}, {"sha": "3b545bb1acdef419c2c59364c78301e6916cc117094abfadc63343847a2cf28b", "index": 1, "path": "824928ca__jinx__micro__conversation__error_worker.py\\3b545bb1acdef419c2c59364c78301e6916cc117094abfadc63343847a2cf28b.json", "terms": ["err", "_err_queue", "await", "get_task", "asyncio", "cancellederror", "none", "with", "shutdown_task", "async", "cancel", "contextlib", "def", "except", "import", "not", "orchestrator", "pass", "shatter", "suppress", "_ensure_error_worker", "_err_worker_task", "enqueue_error_retry", "is_set", "jx_state"], "text_preview": "get_task.cancel()\n                with contextlib.suppress(asyncio.CancelledError):\n                    await get_task\n                break\n            # Process the item\n            shutdown_task.cancel()\n            with contextlib.suppress(asyncio.Canc", "line_start": 37, "line_end": 69}, {"sha": "fb266dc8969926161537bd13657203ec0297a025a20696e4c083465259eb5ca7", "index": 2, "path": "824928ca__jinx__micro__conversation__error_worker.py\\fb266dc8969926161537bd13657203ec0297a025a20696e4c083465259eb5ca7.json", "terms": ["_err_worker_task", "_err_queue", "not", "none", "asyncio", "get_nowait", "task_done", "already", "and", "any", "await", "cancel", "cancellederror", "contextlib", "don", "done", "drain", "except", "exited", "hang", "items", "pass", "pending", "queueempty", "suppress"], "text_preview": "# Drain any pending items so we don't hang if worker already exited\n    if _err_queue is not None:\n        try:\n            while True:\n                _ = _err_queue.get_nowait()\n                _err_queue.task_done()\n        except asyncio.QueueEmpty:\n  ", "line_start": 70, "line_end": 82}], "file_terms": ["none", "_err_queue", "asyncio", "_err_worker_task", "not", "await", "import", "get_task", "shutdown_task", "err", "error", "cancellederror", "contextlib", "def", "done", "queue", "with", "worker", "create_task", "jx_state", "shutdown_event", "the", "and", "async", "cancel"]}