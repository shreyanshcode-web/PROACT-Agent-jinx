{"file_rel": "jinx\\micro\\memory\\api_memory.py", "file_sha256": "f423b72154ac67b296c2e34418020d90e8341ca76a9e426812f63517ad06d594", "updated_ts": 1760763312.368461, "total_chunks": 6, "chunks": [{"sha": "316d56b7a200eab4f951d080e662ea37b22941314397adb1a7480f4f73f5fa1f", "index": 0, "path": "4f404393__jinx__micro__memory__api_memory.py\\316d56b7a200eab4f951d080e662ea37b22941314397adb1a7480f4f73f5fa1f.json", "terms": ["import", "str", "from", "limit", "cut", "jinx", "int", "active", "compact", "mdir", "return", "def", "micro", "memory_dir", "and", "conversation", "head", "join", "path", "tail", "try", "tuple", "__future__", "_paths", "_summarize_agent"], "text_preview": "from __future__ import annotations\n\nimport os\nimport re\nimport hashlib\nfrom typing import Tuple, List\n\nfrom jinx.state import shard_lock\nfrom jinx.async_utils.fs import read_text_raw, write_text\nfrom jinx.micro.memory.storage import memory_dir, ensure_nl, ", "line_start": 1, "line_end": 38}, {"sha": "ce3f0cb8d1f657b7bf02ee70f9cb2b10728f697fe8e53bb5e6ee14719b219f60", "index": 1, "path": "4f404393__jinx__micro__memory__api_memory.py\\ce3f0cb8d1f657b7bf02ee70f9cb2b10728f697fe8e53bb5e6ee14719b219f60.json", "terms": ["text", "lines", "append", "out", "pos", "start", "sha", "close", "len", "code_join", "fence_pat", "head_lines", "tail_lines", "tail", "block", "break", "code", "else", "end", "find", "join", "not", "max_lines", "sha256", "are"], "text_preview": "Code blocks are fenced with ```lang ... ``` or ``` ... ```.\n    \"\"\"\n    if not text:\n        return \"\"\n    out: List[str] = []\n    pos = 0\n    n = len(text)\n    fence_pat = re.compile(r\"```[a-zA-Z0-9_+-]*\\n\")\n    while pos < n:\n        m = fence_pat.search", "line_start": 39, "line_end": 72}, {"sha": "694b587eb731cb43032364fde6e6e8c7b89f52c1f747fe70cfd21eed855e6f1a", "index": 2, "path": "4f404393__jinx__micro__memory__api_memory.py\\694b587eb731cb43032364fde6e6e8c7b89f52c1f747fe70cfd21eed855e6f1a.json", "terms": ["a_s", "append", "entry_active", "not", "active", "and", "compact", "strip", "jinx_text", "user_text", "str", "close", "else", "from", "jinx", "join", "out", "pair", "return", "stores", "text", "the", "tool", "_paths", "_summarize_agent"], "text_preview": "+ \"\\n\".join(tail_lines)\n                + \"\\n```\\n\"\n                + note\n                + \"\\n\"\n            )\n        else:\n            out.append(text[m.start():close+3])\n        pos = close + 3\n    return \"\".join(out)\n\n\nasync def append_turn(user_text:", "line_start": 73, "line_end": 110}, {"sha": "ccad6950af81f3ff68d0bf1fcf370ce7786668fa4ec76e977d414b910583c459", "index": 3, "path": "4f404393__jinx__micro__memory__api_memory.py\\ccad6950af81f3ff68d0bf1fcf370ce7786668fa4ec76e977d414b910583c459.json", "terms": ["a_compact", "base", "entry_compact", "getenv", "int", "max", "compact", "active_path", "a_s", "max_lines", "pt_cap", "append", "else", "except", "exception", "head", "join", "tail", "try", "_summarize_agent", "_summarize_code_blocks", "_trim_to_chars", "entry_active", "entry_active_text", "entry_compact_text"], "text_preview": "entry_active_text = \"\\n\".join(entry_active) + \"\\n\\n\"\n\n    try:\n        # Compact agent text by truncating big code blocks\n        head = max(5, int(os.getenv(\"JINX_API_MEM_CODE_HEAD\", \"20\")))\n        tail = max(0, int(os.getenv(\"JINX_API_MEM_CODE_TAIL\", \"1", "line_start": 111, "line_end": 139}, {"sha": "181df8e0e20fde0cf41f856f80dd7b8b00e73c94b1d2204fceeae27714900dc5", "index": 4, "path": "4f404393__jinx__micro__memory__api_memory.py\\181df8e0e20fde0cf41f856f80dd7b8b00e73c94b1d2204fceeae27714900dc5.json", "terms": ["compact_path", "await", "active_path", "try", "is_followup", "prev_c", "read_text_raw", "topic_shifted", "bool", "and", "else", "except", "exception", "exists", "path", "txt", "ensure_nl", "new_active", "new_compact", "use_active", "write_text", "active", "memory", "use", "not"], "text_preview": "prev = \"\"\n        new_active = (prev or \"\") + entry_active_text\n        try:\n            await write_text(active_path, ensure_nl(new_active))\n        except Exception:\n            pass\n        try:\n            prev_c = await read_text_raw(compact_path) if ", "line_start": 140, "line_end": 171}, {"sha": "1a3cf17bbe8889865e7b67b84d4204c70c5965abb545e63e66aef745f2dac75e", "index": 5, "path": "4f404393__jinx__micro__memory__api_memory.py\\1a3cf17bbe8889865e7b67b84d4204c70c5965abb545e63e66aef745f2dac75e.json", "terms": ["txt", "limit", "memory", "body", "except", "exception", "not", "return", "getenv", "int", "max", "try", "__all__", "_trim_to_chars", "append_turn", "build_api_memory_block", "jinx_api_mem_followup_max_chars", "jinx_api_mem_max_chars", "read_compact", "use_active", "active", "are", "await", "compact", "else"], "text_preview": "except Exception:\n        txt = \"\"\n\n    # Fallback: use legacy compact memory if active files are empty\n    if not txt:\n        try:\n            txt = await read_compact()\n        except Exception:\n            txt = \"\"\n\n    if not txt:\n        return \"\"\n\n ", "line_start": 172, "line_end": 199}], "file_terms": ["compact", "text", "not", "append", "return", "try", "str", "active", "int", "else", "except", "exception", "from", "import", "limit", "and", "txt", "a_s", "jinx", "join", "active_path", "compact_path", "memory", "lines", "await"]}